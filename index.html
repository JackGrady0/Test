<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>åŒ…è£…çš„å­¦é—® - 6ç§ç»„åˆå…¨è§£ç‰ˆ</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Roboto, sans-serif; background: #1a1a1a; touch-action: none; }
        
        /* é¡¶éƒ¨æ•°æ®åŒº */
        #hud {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            background: rgba(30, 30, 30, 0.95); color: #fff;
            padding: 15px 20px; border-radius: 12px; border: 1px solid #444;
            box-shadow: 0 10px 30px rgba(0,0,0,0.6); text-align: center;
            width: 90%; max-width: 500px; user-select: none; pointer-events: none;
            display: flex; flex-direction: column; gap: 8px;
        }

        .hud-row { display: flex; justify-content: space-between; align-items: center; font-size: 14px; color: #aaa; }
        .hud-main { font-size: 32px; font-weight: bold; color: #666; font-family: monospace; margin: 5px 0; transition: color 0.3s;}
        .hud-main.success { color: #4ade80; }
        .hud-detail { font-size: 12px; color: #888; }
        
        /* é‡ç½®æŒ‰é’® */
        #reset-btn {
            position: absolute; top: 20px; right: 20px; pointer-events: auto;
            background: #333; color: white; border: 1px solid #555;
            padding: 8px 15px; border-radius: 6px; cursor: pointer; font-size: 13px;
        }
        #reset-btn:hover { background: #444; }

        /* åº•éƒ¨æ“ä½œæç¤º */
        #controls {
            position: absolute; bottom: 30px; width: 100%; text-align: center; pointer-events: none;
        }
        .tag {
            background: rgba(255,255,255,0.1); color: #ddd; padding: 6px 12px;
            border-radius: 20px; font-size: 12px; display: inline-block; margin: 0 4px; 
            border: 1px solid rgba(255,255,255,0.1); backdrop-filter: blur(4px);
        }
        .tag strong { color: #fff; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.157.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.157.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="hud">
        <div class="hud-row">
            <span>å•ç›’è¡¨é¢ç§¯: 342 cmÂ²</span>
            <span>4ç›’åˆ†æ•£æ€»è®¡: 1368 cmÂ²</span>
        </div>
        <div id="area-display" class="hud-main">ç­‰å¾…æ‹¼åˆ...</div>
        <div id="overlap-display" class="hud-detail">å‡å°‘é¢ç§¯: 0 cmÂ² (æ¥è§¦é¢: 0)</div>
    </div>

    <button id="reset-btn" onclick="window.resetScene()">â†º é‡ç½®ä½ç½®</button>

    <div id="controls">
        <div class="tag">ğŸ–±ï¸ <strong>æ‹–åŠ¨ç©ºç™½</strong> æ—‹è½¬è§†è§’</div>
        <div class="tag">ğŸ‘‡ <strong>åŒå‡»ç›’å­</strong> åˆ‡æ¢å§¿æ€(å¹³/ç«‹/ä¾§)</div>
        <div class="tag">âœ¨ <strong>æ¾æ‰‹</strong> è‡ªåŠ¨å¸é™„å¯¹é½</div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';

        // === ä¸¥è°¨çš„æ•°å­¦å¸¸æ•° ===
        const CONFIG = {
            L: 9, H: 12, W: 3,
            TOTAL_SEPARATE: 1368,
            // å¸é™„é˜ˆå€¼ (cm)
            SNAP_TOLERANCE: 2.5,
            // åªæœ‰å½“é¢å°ºå¯¸å·®å¼‚å°äºæ­¤å€¼æ‰å…è®¸å¸é™„
            SIZE_TOLERANCE: 0.1,
            COLORS: [0x3b82f6, 0xef4444, 0x10b981, 0xf59e0b]
        };

        let scene, camera, renderer, orbit, control;
        let boxes = [];
        const boxInitialStates = []; // ç”¨äºé‡ç½®

        // DOM å…ƒç´ 
        const elDisplay = document.getElementById('area-display');
        const elDetail = document.getElementById('overlap-display');

        init();
        animate();

        function init() {
            // 1. åœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            
            // ç½‘æ ¼è¾…åŠ© (1æ ¼=1cm)
            const grid = new THREE.GridHelper(100, 100, 0x444444, 0x222222);
            scene.add(grid);

            // 2. ç›¸æœº (è®¾ç½®åœ¨ 45 åº¦è§’ï¼Œè§†é‡æ¸…æ™°)
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(30, 35, 40);
            camera.lookAt(0, 0, 0);

            // 3. æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // 4. ç¯å…‰
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(15, 30, 15);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            // 5. åˆ›å»ºç›’å­
            createBoxes();

            // 6. æ§åˆ¶å™¨
            orbit = new OrbitControls(camera, renderer.domElement);
            orbit.enableDamping = true;
            orbit.maxPolarAngle = Math.PI / 2 - 0.1; // ç¦æ­¢é’»åœ°

            control = new TransformControls(camera, renderer.domElement);
            control.setTranslationSnap(null); // ç§»åŠ¨æ—¶ä¸å¸é™„ï¼Œæ¾æ‰‹æ‰å¸é™„
            control.setRotationSnap(Math.PI/2);
            scene.add(control);

            setupEvents();
        }

        function createBoxes() {
            const geometry = new THREE.BoxGeometry(CONFIG.L, CONFIG.H, CONFIG.W);
            
            // åˆå§‹ä½ç½®ï¼šåˆ†æ•£æ‘†æ”¾
            const positions = [
                {x: -8, z: -8}, {x: 8, z: -8}, {x: -8, z: 8}, {x: 8, z: 8}
            ];

            for (let i = 0; i < 4; i++) {
                const material = new THREE.MeshStandardMaterial({ 
                    color: CONFIG.COLORS[i], roughness: 0.4, metalness: 0.1 
                });
                const box = new THREE.Mesh(geometry, material);
                
                // é»˜è®¤å§¿æ€ï¼šç«‹ç€ (9x12x3)
                box.position.set(positions[i].x, CONFIG.H/2, positions[i].z);
                
                box.castShadow = true;
                box.receiveShadow = true;
                box.userData = { 
                    id: i, 
                    orientation: 0 // 0:ç«‹, 1:å¹³, 2:ä¾§
                };

                // è¾¹ç¼˜çº¿æ¡† (é«˜äº®ç”¨)
                const edges = new THREE.LineSegments(
                    new THREE.EdgesGeometry(geometry),
                    new THREE.LineBasicMaterial({ color: 0x000000, opacity: 0.3, transparent: true })
                );
                box.add(edges);
                box.userData.edges = edges;

                scene.add(box);
                boxes.push(box);
                
                // ä¿å­˜åˆå§‹çŠ¶æ€ç”¨äºé‡ç½®
                boxInitialStates.push({
                    pos: box.position.clone(),
                    rot: box.rotation.clone(),
                    scale: box.scale.clone() // è™½ç„¶ä¸ç¼©æ”¾ï¼Œä½†ä¸ºäº†ç»Ÿä¸€æ­¥éª¤
                });
            }
        }

        // è·å–ç›’å­åœ¨ä¸–ç•Œåæ ‡ç³»ä¸‹çš„å®é™…å°ºå¯¸ (Bounding Box Size)
        function getWorldSize(obj) {
            const box3 = new THREE.Box3().setFromObject(obj);
            const size = new THREE.Vector3();
            box3.getSize(size);
            // æ¶ˆé™¤æµ®ç‚¹è¯¯å·®
            size.x = Math.round(size.x);
            size.y = Math.round(size.y);
            size.z = Math.round(size.z);
            return size;
        }

        function setupEvents() {
            // æ‹–æ‹½ç›‘å¬
            control.addEventListener('dragging-changed', (event) => {
                orbit.enabled = !event.value;
                
                if (!event.value) {
                    // æ‹–æ‹½ç»“æŸï¼šæ‰§è¡Œå¸é™„å’Œè®¡ç®—
                    const obj = control.object;
                    attemptSnap(obj);
                    updateCalculation();
                }
            });

            // æ‹–æ‹½è¿‡ç¨‹ï¼šé˜²ç©¿åœ°
            control.addEventListener('change', () => {
                if(control.dragging && control.object) {
                    const obj = control.object;
                    const size = getWorldSize(obj);
                    if(obj.position.y < size.y/2) obj.position.y = size.y/2;
                }
            });

            // ç‚¹å‡»é€‰ä¸­
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();

            renderer.domElement.addEventListener('pointerdown', (e) => {
                if(control.dragging) return;
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(boxes);

                if(intersects.length > 0) {
                    control.attach(intersects[0].object);
                } else {
                    control.detach();
                }
            });

            // åŒå‡»åˆ‡æ¢å§¿æ€ (æ ¸å¿ƒåŠŸèƒ½ï¼šæ”¯æŒæ‰€æœ‰6ç§ç»„åˆçš„å…³é”®)
            renderer.domElement.addEventListener('dblclick', (e) => {
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(boxes);

                if(intersects.length > 0) {
                    const obj = intersects[0].object;
                    cycleOrientation(obj);
                    attemptSnap(obj); // å˜å®Œå§¿æ€å°è¯•å¸é™„
                    updateCalculation();
                }
            });
        }

        // åˆ‡æ¢ç›’å­çš„ä¸‰ç§ä¸»å§¿æ€
        function cycleOrientation(obj) {
            // å§¿æ€ 0: åŸå§‹ (9, 12, 3)
            // å§¿æ€ 1: èººå¹³ (9, 3, 12) - ç»•Xè½¬90
            // å§¿æ€ 2: ä¾§ç«‹ (3, 12, 9) - ç»•Yè½¬90
            
            let nextState = (obj.userData.orientation + 1) % 3;
            obj.userData.orientation = nextState;

            // é‡ç½®æ—‹è½¬
            obj.rotation.set(0, 0, 0);

            if (nextState === 1) {
                obj.rotation.x = -Math.PI / 2;
            } else if (nextState === 2) {
                obj.rotation.y = -Math.PI / 2;
            }
            // å§¿æ€0 ä¿æŒ 0,0,0

            obj.updateMatrixWorld();
            
            // è°ƒæ•´Yä½ç½®é˜²æ­¢é™·å…¥åœ°é¢
            const size = getWorldSize(obj);
            if(obj.position.y < size.y/2) obj.position.y = size.y/2;
        }

        // === æ ¸å¿ƒé€»è¾‘ï¼šä¸¥è°¨å¸é™„ ===
        function attemptSnap(activeBox) {
            const mySize = getWorldSize(activeBox);
            const myBB = new THREE.Box3().setFromObject(activeBox);
            
            let bestSnap = null;
            let minDistance = CONFIG.SNAP_TOLERANCE;

            // éå†å…¶ä»–ç›’å­å¯»æ‰¾å¸é™„ç‚¹
            for (let other of boxes) {
                if (other === activeBox) continue;
                
                const otherSize = getWorldSize(other);
                const otherBB = new THREE.Box3().setFromObject(other);
                
                // è®¡ç®—ä¸­å¿ƒè·ç¦»çŸ¢é‡
                const diff = new THREE.Vector3().subVectors(activeBox.position, other.position);
                const absX = Math.abs(diff.x);
                const absY = Math.abs(diff.y);
                const absZ = Math.abs(diff.z);

                // ç†æƒ³ä¸­å¿ƒè·
                const idealX = (mySize.x + otherSize.x) / 2;
                const idealY = (mySize.y + otherSize.y) / 2;
                const idealZ = (mySize.z + otherSize.z) / 2;

                // æ£€æŸ¥ X è½´æ–¹å‘å¸é™„ (å·¦å³è´´åˆ)
                // æ¡ä»¶ï¼šè·ç¦»æ¥è¿‘idealXï¼Œä¸”å¦å¤–ä¸¤è½´å¯¹é½ï¼Œä¸”æ¥è§¦é¢å°ºå¯¸ä¸€è‡´
                if (Math.abs(absX - idealX) < minDistance) {
                    // Yå’ŒZå¿…é¡»å¯¹é½ (è¯¯å·®å…è®¸æå°)
                    if (absY < 1.0 && absZ < 1.0) {
                        // æ£€æŸ¥é¢åŒ¹é…: æ­¤æ—¶æ¥è§¦é¢æ˜¯ YZ å¹³é¢
                        // è¦æ±‚ my.Y == other.Y && my.Z == other.Z
                        if (Math.abs(mySize.y - otherSize.y) < CONFIG.SIZE_TOLERANCE &&
                            Math.abs(mySize.z - otherSize.z) < CONFIG.SIZE_TOLERANCE) {
                            
                            minDistance = Math.abs(absX - idealX);
                            bestSnap = {
                                pos: new THREE.Vector3(
                                    other.position.x + (diff.x > 0 ? idealX : -idealX),
                                    other.position.y,
                                    other.position.z
                                )
                            };
                        }
                    }
                }

                // æ£€æŸ¥ Y è½´æ–¹å‘å¸é™„ (ä¸Šä¸‹å †å )
                if (Math.abs(absY - idealY) < minDistance) {
                    if (absX < 1.0 && absZ < 1.0) {
                        // æ¥è§¦é¢ XZ
                        if (Math.abs(mySize.x - otherSize.x) < CONFIG.SIZE_TOLERANCE &&
                            Math.abs(mySize.z - otherSize.z) < CONFIG.SIZE_TOLERANCE) {
                            
                            minDistance = Math.abs(absY - idealY);
                            bestSnap = {
                                pos: new THREE.Vector3(
                                    other.position.x,
                                    other.position.y + (diff.y > 0 ? idealY : -idealY),
                                    other.position.z
                                )
                            };
                        }
                    }
                }

                // æ£€æŸ¥ Z è½´æ–¹å‘å¸é™„ (å‰åè´´åˆ)
                if (Math.abs(absZ - idealZ) < minDistance) {
                    if (absX < 1.0 && absY < 1.0) {
                        // æ¥è§¦é¢ XY
                        if (Math.abs(mySize.x - otherSize.x) < CONFIG.SIZE_TOLERANCE &&
                            Math.abs(mySize.y - otherSize.y) < CONFIG.SIZE_TOLERANCE) {
                            
                            minDistance = Math.abs(absZ - idealZ);
                            bestSnap = {
                                pos: new THREE.Vector3(
                                    other.position.x,
                                    other.position.y,
                                    other.position.z + (diff.z > 0 ? idealZ : -idealZ)
                                )
                            };
                        }
                    }
                }
            }

            if (bestSnap) {
                activeBox.position.copy(bestSnap.pos);
            }
        }

        // === æ ¸å¿ƒé€»è¾‘ï¼šåŸºäº AABB äº¤é›†çš„ç²¾å‡†è®¡ç®— ===
        function updateCalculation() {
            let totalOverlapArea = 0;
            let contactCount = 0;
            let connectedPairs = 0;

            // 1. é‡ç½®é«˜äº®
            boxes.forEach(b => {
                b.userData.edges.material.color.setHex(0x000000);
                b.userData.edges.material.opacity = 0.3;
            });

            // 2. æ„å»ºå¹¶æŸ¥é›†/å›¾æ¥æ£€æŸ¥å…¨è¿é€šæ€§
            const adj = new Array(4).fill(0).map(() => []);

            // 3. ä¸¤ä¸¤æ£€æŸ¥é‡å 
            for (let i = 0; i < boxes.length; i++) {
                for (let j = i + 1; j < boxes.length; j++) {
                    const b1 = boxes[i];
                    const b2 = boxes[j];

                    // è·å–ç¨å¾®ç¼©å°ä¸€ç‚¹çš„ AABBï¼Œé¿å…è¾¹ç¼˜è¯¯è§¦
                    // ä½†ä¸ºäº†è®¡ç®—é‡å é¢ï¼Œæˆ‘ä»¬ä½¿ç”¨å®é™…å°ºå¯¸é€»è¾‘
                    
                    const p1 = b1.position;
                    const p2 = b2.position;
                    const s1 = getWorldSize(b1);
                    const s2 = getWorldSize(b2);

                    // æ£€æŸ¥ä¸­å¿ƒè·æ˜¯å¦ç­‰äºå°ºå¯¸å’Œçš„ä¸€åŠ (ä¸¥ä¸åˆç¼)
                    const dx = Math.abs(p1.x - p2.x);
                    const dy = Math.abs(p1.y - p2.y);
                    const dz = Math.abs(p1.z - p2.z);
                    
                    const idealX = (s1.x + s2.x)/2;
                    const idealY = (s1.y + s2.y)/2;
                    const idealZ = (s1.z + s2.z)/2;
                    
                    const eps = 0.05; // æå°è¯¯å·®
                    let area = 0;

                    // Xè½´ç´§è´´
                    if (Math.abs(dx - idealX) < eps && dy < eps && dz < eps) {
                        area = s1.y * s1.z; // æ¥è§¦é¢ Y*Z
                    }
                    // Yè½´ç´§è´´
                    else if (Math.abs(dy - idealY) < eps && dx < eps && dz < eps) {
                        area = s1.x * s1.z; // æ¥è§¦é¢ X*Z
                    }
                    // Zè½´ç´§è´´
                    else if (Math.abs(dz - idealZ) < eps && dx < eps && dy < eps) {
                        area = s1.x * s1.y; // æ¥è§¦é¢ X*Y
                    }

                    if (area > 0) {
                        // å‘ç°æœ‰æ•ˆæ¥è§¦
                        totalOverlapArea += area;
                        contactCount++;
                        adj[i].push(j);
                        adj[j].push(i);

                        // é«˜äº®è¾¹ç¼˜
                        b1.userData.edges.material.color.setHex(0xffffff);
                        b1.userData.edges.material.opacity = 1.0;
                        b2.userData.edges.material.color.setHex(0xffffff);
                        b2.userData.edges.material.opacity = 1.0;
                    }
                }
            }

            // 4. æ£€æŸ¥è¿é€šæ€§ (BFS)
            const visited = new Set();
            const q = [0]; 
            visited.add(0);
            while(q.length) {
                const u = q.shift();
                for(const v of adj[u]) {
                    if(!visited.has(v)) {
                        visited.add(v);
                        q.push(v);
                    }
                }
            }

            // 5. æ›´æ–° UI
            const saved = totalOverlapArea * 2; // ä¸¤ä¸ªé¢
            const finalArea = CONFIG.TOTAL_SEPARATE - saved;

            if (visited.size === 4) {
                elDisplay.innerText = `æ€»è¡¨é¢ç§¯: ${finalArea} cmÂ²`;
                elDisplay.className = "hud-main success";
                elDetail.innerText = `(æ‹¼æ­æˆåŠŸ | å‡å°‘é¢ç§¯: ${saved} cmÂ²)`;
            } else {
                elDisplay.innerText = "ç­‰å¾…æ‹¼åˆ...";
                elDisplay.className = "hud-main";
                elDetail.innerText = `(å½“å‰è¿æ¥ç»„ä»¶æ•°: ${visited.size}/4 | å‡å°‘: ${saved})`;
            }
        }

        // å…¨å±€é‡ç½®å‡½æ•°
        window.resetScene = function() {
            boxes.forEach((box, i) => {
                const init = boxInitialStates[i];
                box.position.copy(init.pos);
                box.rotation.copy(init.rot);
                box.userData.orientation = 0;
                control.detach();
            });
            updateCalculation();
        };

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        window.addEventListener('resize', onWindowResize);

        function animate() {
            requestAnimationFrame(animate);
            orbit.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>